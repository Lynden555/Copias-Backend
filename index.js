const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const multer = require('multer');
const path = require('path');
const bcrypt = require('bcrypt');
const { Expo } = require('expo-server-sdk');
const expo = new Expo();

const app = express();
app.use(cors());
app.use(express.json({ limit: '10mb' }));
app.use('/uploads', express.static('uploads'));

app.use((req, res, next) => {
  req.clienteNombre = req.headers['cliente-nombre'] || null;
  next();
});

 

app.post('/suscribirse', async (req, res) => {
  const { subscription, tecnicoId } = req.body;

  if (!subscription || !tecnicoId) {
    return res.status(400).json({ error: 'Faltan datos: subscription o tecnicoId' });
  }

  // Validar si el t√©cnico existe
  const tecnico = await Tecnico.findOne({ tecnicoId });
  if (!tecnico) {
    return res.status(404).json({ error: 'T√©cnico no encontrado' });
  }

  try {
    // Elimina suscripciones duplicadas de ese t√©cnico
    await WebPushSubscription.deleteMany({ tecnicoId });

    const nuevaSuscripcion = new WebPushSubscription({
      tecnicoId,
      subscription
    });

    await nuevaSuscripcion.save();
    res.status(201).json({ message: '‚úÖ Suscripci√≥n registrada correctamente' });
  } catch (error) {
    console.error('‚ùå Error al guardar suscripci√≥n:', error);
    res.status(500).json({ error: 'Error al guardar suscripci√≥n' });
  }
});



const enviarNotificacionATecnico = async ({ tecnicoId, title, body }) => {
  try {
    const tokenData = await PushToken.findOne({ tecnicoId });
    if (!tokenData || !Expo.isExpoPushToken(tokenData.expoPushToken)) {
      console.log(`‚ùå Token inv√°lido o no encontrado para tecnicoId: ${tecnicoId}`);
      return;
    }

    const mensaje = [{
      to: tokenData.expoPushToken,
      sound: 'default',
      title,
      body,
      data: { tipo: 'tecnico', tecnicoId }, // üëà Etiqueta para filtrar en app
    }];

    await expo.sendPushNotificationsAsync(mensaje);
    console.log('üì§ Notificaci√≥n enviada a t√©cnico:', tecnicoId);
  } catch (error) {
    console.error('‚ùå Error al enviar notificaci√≥n a t√©cnico:', error);
  }
};

const enviarNotificacionACliente = async ({ clienteId, title, body }) => {
  try {
    const tokensData = await PushToken.find({ clienteId }); // üëà Busca TODOS los tokens

    const tokensValidos = tokensData
      .map(t => t.expoPushToken)
      .filter(token => Expo.isExpoPushToken(token));

    if (tokensValidos.length === 0) {
      console.log(`‚ùå No hay tokens v√°lidos para clienteId: ${clienteId}`);
      return;
    }

    // Crear mensajes para todos los tokens
    const mensajes = tokensValidos.map(token => ({
      to: token,
      sound: 'default',
      title,
      body,
      data: { tipo: 'cliente', clienteId },
    }));

    await expo.sendPushNotificationsAsync(mensajes);
    console.log(`üì§ Notificaci√≥n enviada a ${tokensValidos.length} dispositivo(s) del cliente: ${clienteId}`);
  } catch (error) {
    console.error('‚ùå Error al enviar notificaci√≥n a cliente:', error);
  }
};



mongoose
  .connect('mongodb+srv://DiegoLLera:666bonus@cluster0.l40i6a0.mongodb.net/copiadoras?retryWrites=true&w=majority&appName=Cluster0')
  .then(() => console.log('‚úÖ Conectado a MongoDB Atlas correctamente'))
  .catch((err) => console.error('‚ùå Error al conectar a MongoDB Atlas:', err));



const ticketSchema = new mongoose.Schema({
  clienteNombre: String,
  empresa: String,
  area: String,
  telefono: String,
  impresora: String,
  descripcionFalla: String,
  fotos: [String],
  estado: { type: String, default: 'Pendiente' },
  tecnicoAsignado: { type: String, default: null },
  fechaCreacion: { type: Date, default: Date.now },
  clienteId: String,
  tecnicoId: String
});

const Ticket = mongoose.model('Ticket', ticketSchema);

const tonerSchema = new mongoose.Schema({
  clienteNombre: String,
  empresa: String,
  area: String,
  telefono: String,
  impresora: String,
  estado: { type: String, default: 'Pendiente' },
  tecnicoAsignado: { type: String, default: null },
  fechaCreacion: { type: Date, default: Date.now },
  clienteId: String,
  tecnicoId: String
});
const Toner = mongoose.model('Toner', tonerSchema,);


const tecnicoSchema = new mongoose.Schema({
  nombre: String,
  fotoUrl: String,
  tecnicoId: String
});

const Tecnico = mongoose.model('Tecnico', tecnicoSchema);

const usuarioSchema = new mongoose.Schema({
  email: String,
  password: String,
  activo: Boolean,
});
const Usuario = mongoose.model('Usuario', usuarioSchema);

const pushTokenSchema = new mongoose.Schema({
  clienteId: { type: String, default: null },
  tecnicoId: { type: String, default: null },
  expoPushToken: { type: String, required: true },
});
const PushToken = mongoose.model('PushToken', pushTokenSchema);

const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, 'uploads/');
  },
  filename: function (req, file, cb) {
    cb(null, Date.now() + path.extname(file.originalname));
  },
});
const upload = multer({ storage });

app.post('/tickets', upload.array('fotos'), async (req, res) => {
  try {
    const { clienteNombre, empresa, area, telefono, impresora, descripcionFalla, clienteId } = req.body;
    const fotos = req.files?.map(file => `https://copias-backend-production.up.railway.app/uploads/${file.filename}`) || [];

    const nuevoTicket = new Ticket({
      clienteNombre,
      empresa,
      area,
      telefono,
      impresora,
      descripcionFalla,
      clienteId,
      fotos
    });

    await nuevoTicket.save();

await enviarNotificacionACliente({
  clienteId,
  title: 'üì¢ Ticket creado',
  body: `Gracias por reportar: ${descripcionFalla}`,
});

    res.json(nuevoTicket);
  } catch (error) {
    console.error('Error al crear ticket:', error);
    res.status(500).json({ error: 'Error al crear ticket' });
  }
});

app.post('/toner', upload.none(), async (req, res) => {
  try {
    const { clienteNombre, empresa, area, telefono, impresora, clienteId } = req.body;

    const nuevoToner = new Toner({
      clienteNombre,
      empresa,
      area,
      telefono,
      impresora,
      clienteId
    });

    await nuevoToner.save();
    console.log('‚úÖ Pedido de t√≥ner guardado:', nuevoToner);

    await enviarNotificacionACliente({
      clienteId,
      title: 'üü£ Pedido registrado',
      body: `Tu pedido de t√≥ner fue recibido correctamente.`,
    });

    res.status(201).json({ message: 'Pedido de t√≥ner registrado correctamente', toner: nuevoToner });
  } catch (error) {
    console.error('‚ùå Error al registrar pedido de t√≥ner:', error);
    res.status(500).json({ error: 'Error al registrar pedido de t√≥ner' });
  }
});

// ‚úÖ Ruta para actualizar estado o t√©cnico del T√ìNER
app.patch('/toners/:id', async (req, res) => {
  try {
    const tonerAnterior = await Toner.findById(req.params.id);
    const toner = await Toner.findByIdAndUpdate(req.params.id, req.body, { new: true });

    if (!toner) return res.status(404).json({ error: 'T√≥ner no encontrado' });

  
if (!tonerAnterior.tecnicoAsignado && toner.tecnicoAsignado) {
  await enviarNotificacionACliente({
    clienteId: toner.clienteId,
    title: 'üë®‚Äçüîß T√©cnico asignado a tu pedido de t√≥ner',
    body: `T√©cnico ${toner.tecnicoAsignado} ha sido asignado a tu pedido en ${toner.empresa} - ${toner.area}.`,
  });


  await enviarNotificacionATecnico({
  tecnicoId: toner.tecnicoId,
  title: 'üì¶ Nuevo pedido de t√≥ner',
  body: `Tienes un pedido en ${toner.empresa} - ${toner.area}`
});}

    res.json(toner);
  } catch (error) {
    console.error('‚ùå Error al actualizar t√≥ners:', error);
    res.status(500).json({ error: 'Error al actualizar t√≥ners' });
  }
});
app.delete('/toners/:id', async (req, res) => {
  try {
    await Toner.findByIdAndDelete(req.params.id);
    res.json({ message: 'T√≥ner eliminado correctamente' });
  } catch (error) {
    console.error('Error al eliminar t√≥ner:', error);
    res.status(500).json({ error: 'Error al eliminar t√≥ner' });
  }
});

app.get('/tickets', async (req, res) => {
  try {
    const clienteNombre = req.headers['cliente-nombre'];
    let tickets;

    if (clienteNombre) {
      tickets = await Ticket.find({ clienteNombre });
    } else {
      tickets = await Ticket.find();
    }

    res.json(tickets);
  } catch (error) {
    console.error('Error al obtener tickets:', error);
    res.status(500).json({ error: 'Error al obtener tickets' });
  }
});


app.get('/toners', async (req, res) => {
  try {
    const clienteId = req.headers['cliente-id'];
    const query = clienteId ? { clienteId } : {};

    const toners = await Toner.find(query);
    res.json(toners);
  } catch (error) {
    console.error('‚ùå Error al obtener t√≥ners:', error);
    res.status(500).json({ error: 'Error al obtener t√≥ners' });
  }
});

app.get('/tickets/:id', async (req, res) => {
  try {
    const ticket = await Ticket.findById(req.params.id);
    if (!ticket) return res.status(404).json({ error: 'Ticket no encontrado' });
    res.json(ticket);
  } catch (error) {
    console.error('Error al obtener ticket:', error);
    res.status(500).json({ error: 'Error al obtener ticket' });
  }
});


app.get('/toners/:id', async (req, res) => {
  try {
    const toner = await Toner.findById(req.params.id);
    if (!toner) return res.status(404).json({ error: 'T√≥ner no encontrado' });
    res.json(toner);
  } catch (error) {
    console.error('Error al obtener toner:', error);
    res.status(500).json({ error: 'Error al obtener toner' });
  }
});

app.patch('/tickets/:id', async (req, res) => {
  try {
    const ticketAnterior = await Ticket.findById(req.params.id);
    const ticket = await Ticket.findByIdAndUpdate(req.params.id, req.body, { new: true });

    if (!ticket) return res.status(404).json({ error: 'Ticket no encontrado' });

    // ‚úÖ Notificaci√≥n cuando se asigna un t√©cnico
if (!ticketAnterior.tecnicoAsignado && ticket.tecnicoAsignado) {
    await enviarNotificacionACliente({
    clienteId: ticket.clienteId,
    title: 'üë®‚Äçüîß T√©cnico asignado a tu ticket',
    body: `T√©cnico ${ticket.tecnicoAsignado} ha sido asignado a tu ticket en ${ticket.empresa} - ${ticket.area}.`,
    });

    await enviarNotificacionATecnico({
    tecnicoId: ticket.tecnicoId,
    title: 'üì• Nuevo ticket asignado',
    body: `Tienes un ticket en ${ticket.empresa} - ${ticket.area}`
});
}

    res.json(ticket);
  } catch (error) {
    console.error('Error al actualizar ticket:', error);
    res.status(500).json({ error: 'Error al actualizar ticket' });
  }
});

app.delete('/tickets/:id', async (req, res) => {
  try {
    await Ticket.findByIdAndDelete(req.params.id);
    res.json({ message: 'Ticket eliminado correctamente' });
  } catch (error) {
    console.error('Error al eliminar ticket:', error);
    res.status(500).json({ error: 'Error al eliminar ticket' });
  }
});

app.get('/tecnicos', async (req, res) => {
  try {
    const tecnicos = await Tecnico.find();
    res.json(tecnicos);
  } catch (error) {
    console.error('Error al obtener t√©cnicos:', error);
    res.status(500).json({ error: 'Error al obtener t√©cnicos' });
  }
});

// ‚úÖ NUEVA RUTA PARA AGREGAR T√âCNICOS
app.post('/tecnicos', async (req, res) => {
  try {
   const { nombre, fotoUrl, tecnicoId } = req.body;

    const nuevoTecnico = new Tecnico({
      nombre,
      fotoUrl,
      tecnicoId
    });

    await nuevoTecnico.save();

    res.status(201).json({ message: 'T√©cnico agregado correctamente', tecnico: nuevoTecnico });
  } catch (error) {
    console.error('Error al agregar t√©cnico:', error);
    res.status(500).json({ error: 'Error al agregar t√©cnico' });
  }
});

app.delete('/tecnicos/:id', async (req, res) => {
  try {
    await Tecnico.findByIdAndDelete(req.params.id);
    res.json({ message: 'T√©cnico eliminado correctamente' });
  } catch (error) {
    console.error('Error al eliminar t√©cnico:', error);
    res.status(500).json({ error: 'Error al eliminar t√©cnico' });
  }
});

app.patch('/tecnicos/:id', upload.single('foto'), async (req, res) => {
  try {
    const tecnico = await Tecnico.findById(req.params.id);
    if (!tecnico) {
      return res.status(404).json({ error: 'T√©cnico no encontrado' });
    }

    if (req.body.nombre) {
      tecnico.nombre = req.body.nombre;
    }

    if (req.file) {
      const fotoUrl = `https://copias-backend-production.up.railway.app/uploads/${req.file.filename}`;
      tecnico.fotoUrl = fotoUrl;
    }

    await tecnico.save();
    res.json({ message: 'T√©cnico actualizado correctamente', tecnico });
  } catch (error) {
    console.error('Error al actualizar t√©cnico:', error);
    res.status(500).json({ error: 'Error al actualizar t√©cnico' });
  }
});

app.post('/login', async (req, res) => {
  const { email, password } = req.body;
  try {
    const usuario = await Usuario.findOne({ email });
    if (!usuario) {
      return res.status(401).json({ error: 'Usuario no encontrado' });
    }

    const passwordOk = await bcrypt.compare(password, usuario.password);
    if (!passwordOk) {
      return res.status(401).json({ error: 'Contrase√±a incorrecta' });
    }

    if (!usuario.activo) {
      return res.status(403).json({ error: 'Licencia inactiva, contacta a soporte' });
    }

    res.json({ message: 'Login exitoso' });
  } catch (error) {
    console.error('Error en login:', error);
    res.status(500).json({ error: 'Error en login' });
  }
});

app.post('/validar-licencia', async (req, res) => {
  const { licencia } = req.body;

  if (!licencia || licencia.trim() === '') {
    return res.status(400).json({ validado: false, error: 'Licencia vac√≠a' });
  }

  res.json({ validado: true });
});

app.post('/registrar-token', async (req, res) => {
  const { clienteId, tecnicoId, expoPushToken } = req.body;

  if ((!clienteId && !tecnicoId) || !expoPushToken) {
    return res.status(400).json({ error: '‚ùå Datos incompletos' });
  }

  if (!expoPushToken.startsWith('ExponentPushToken')) {
    return res.status(400).json({ error: '‚ùå Token inv√°lido' });
  }

  try {
    // 1Ô∏è‚É£ Verificar si el token ya existe para este dispositivo
    const tokenExistente = await PushToken.findOne({ expoPushToken });
    
    if (tokenExistente) {
      // Actualizar los IDs si es el mismo dispositivo
      tokenExistente.clienteId = clienteId || tokenExistente.clienteId;
      tokenExistente.tecnicoId = tecnicoId || tokenExistente.tecnicoId;
      await tokenExistente.save();
    } else {
      // 2Ô∏è‚É£ Crear nuevo registro si no existe
      const nuevoToken = new PushToken({ clienteId, tecnicoId, expoPushToken });
      await nuevoToken.save();
    }

    res.status(200).json({ message: '‚úÖ Token registrado correctamente' });
  } catch (error) {
    console.error('‚ùå Error al guardar token push:', error);
    res.status(500).json({ error: '‚ùå Error interno al guardar token' });
  }
});

app.get('/tickets-tecnico', async (req, res) => {
  const licencia = req.headers['tecnico-licencia'];

  if (!licencia) {
    return res.status(400).json({ error: 'Licencia no proporcionada' });
  }

  try {
    const tickets = await Ticket.find({ tecnicoAsignado: licencia });
    res.json(tickets);
  } catch (error) {
    console.error('Error al obtener tickets para t√©cnico:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
});

app.post('/tickets/:id/finalizar', upload.array('fotosTecnico'), async (req, res) => {
  try {
    const ticket = await Ticket.findById(req.params.id);
    if (!ticket) return res.status(404).json({ error: 'Ticket no encontrado' });

    const comentario = req.body.comentario || '';
    const nuevasFotos = req.files?.map(file => `https://copias-backend-production.up.railway.app/uploads/${file.filename}`) || [];

ticket.estado = 'Terminado';

    ticket.fotos.push(...nuevasFotos);
    // ticket.comentarioTecnico = comentario; // Si decides guardar comentarios en el modelo

    await ticket.save();

    res.json(ticket);
  } catch (error) {
    console.error('Error al finalizar ticket:', error);
    res.status(500).json({ error: 'Error al finalizar ticket' });
  }
});
// ‚úÖ Nueva ruta: obtener t√≥ners asignados a un t√©cnico
app.get('/toners-tecnico', async (req, res) => {
  const licencia = req.headers['tecnico-licencia'];

  if (!licencia) {
    return res.status(400).json({ error: 'Licencia no proporcionada' });
  }

  try {
    const toners = await Toner.find({ tecnicoAsignado: licencia });
    res.json(toners);
  } catch (error) {
    console.error('Error al obtener t√≥ners para t√©cnico:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
});

app.post('/logout-token', async (req, res) => {
  const { expoPushToken } = req.body;
  if (!expoPushToken) return res.status(400).json({ error: 'Token faltante' });

  await PushToken.deleteMany({ expoPushToken });
  res.status(200).json({ message: 'Token eliminado' });
});

const PORT = 3000;
app.listen(PORT, () => {
  console.log(`Servidor corriendo en http://localhost:${PORT}`);
  
});

