const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const multer = require('multer');
const path = require('path');
const bcrypt = require('bcrypt');
const webpush = require('web-push'); // ‚úÖ Nuevo
const { publicKey, privateKey } = require('./vapidkeys'); // ‚úÖ Nuevo
const { Expo } = require('expo-server-sdk');
const expo = new Expo();

const app = express();
app.use(cors());
app.use(express.json({ limit: '10mb' }));
app.use('/uploads', express.static('uploads'));

app.use((req, res, next) => {
  req.clienteNombre = req.headers['cliente-nombre'] || null;
  next();
});

// ‚úÖ Configuraci√≥n de web-push
webpush.setVapidDetails(
  'mailto:soporte@tuservidor.com',
  publicKey,
  privateKey
);

// ‚úÖ Almac√©n temporal de suscripciones (puedes mover esto a base de datos)
let suscripciones = [];

app.post('/suscribirse', (req, res) => {
  const suscripcion = req.body;
  suscripciones.push(suscripcion);
  res.status(201).json({ message: '‚úÖ Suscripci√≥n registrada' });
});

// ‚úÖ Funci√≥n para enviar notificaciones a todos
const enviarNotificacion = (payload) => {
  suscripciones.forEach(sub =>
    webpush.sendNotification(sub, JSON.stringify(payload)).catch(err => console.error('‚ùå Error al enviar noti:', err))
  );
};

const enviarNotificacionExpo = async ({ title, body }) => {
  try {
    const tokensDB = await PushToken.find();

    const mensajes = tokensDB
      .filter(t => Expo.isExpoPushToken(t.expoPushToken))
      .map(t => ({
        to: t.expoPushToken,
        sound: 'default',
        title,
        body,
      }));

    const chunks = expo.chunkPushNotifications(mensajes);

    if (mensajes.length === 0) {
  console.log('üì≠ No hay tokens v√°lidos para notificar');
  return;
}
    for (let chunk of chunks) {
      await expo.sendPushNotificationsAsync(chunk);
    }
    console.log('üì§ Notificaciones Expo enviadas');
  } catch (error) {
    console.error('‚ùå Error al enviar notificaciones Expo:', error);
  }
};

const enviarNotificacionACliente = async ({ clienteId, title, body }) => {
  try {
    const tokenData = await PushToken.findOne({ clienteId });
    if (!tokenData || !Expo.isExpoPushToken(tokenData.expoPushToken)) {
      console.log(`‚ùå Token inv√°lido o no encontrado para clienteId: ${clienteId}`);
      return;
    }

    const mensaje = [{
      to: tokenData.expoPushToken,
      sound: 'default',
      title,
      body,
    }];

    await expo.sendPushNotificationsAsync(mensaje);
    console.log('üì§ Notificaci√≥n enviada a cliente:', clienteId);
  } catch (error) {
    console.error('‚ùå Error al enviar notificaci√≥n a cliente:', error);
  }
};



mongoose
  .connect('mongodb+srv://DiegoLLera:666bonus@cluster0.l40i6a0.mongodb.net/copiadoras?retryWrites=true&w=majority&appName=Cluster0')
  .then(() => console.log('‚úÖ Conectado a MongoDB Atlas correctamente'))
  .catch((err) => console.error('‚ùå Error al conectar a MongoDB Atlas:', err));

const ticketSchema = new mongoose.Schema({
  clienteNombre: String,
  empresa: String,
  area: String,
  telefono: String,
  impresora: String,
  descripcionFalla: String,
  fotos: [String],
  estado: { type: String, default: 'Pendiente' },
  tecnicoAsignado: { type: String, default: null },
  fechaCreacion: { type: Date, default: Date.now },
  clienteId: String
});

const Ticket = mongoose.model('Ticket', ticketSchema);

const tonerSchema = new mongoose.Schema({
  clienteNombre: String,
  empresa: String,
  area: String,
  telefono: String,
  impresora: String,
  estado: { type: String, default: 'Pendiente' },
  tecnicoAsignado: { type: String, default: null },
  fechaCreacion: { type: Date, default: Date.now },
  clienteId: String
});
const Toner = mongoose.model('Toner', tonerSchema,);


const tecnicoSchema = new mongoose.Schema({
  nombre: String,
  fotoUrl: String,
});
const Tecnico = mongoose.model('Tecnico', tecnicoSchema);

const usuarioSchema = new mongoose.Schema({
  email: String,
  password: String,
  activo: Boolean,
});
const Usuario = mongoose.model('Usuario', usuarioSchema);

const pushTokenSchema = new mongoose.Schema({
  clienteId: { type: String, required: true },
  expoPushToken: { type: String, required: true },
});
const PushToken = mongoose.model('PushToken', pushTokenSchema);

const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, 'uploads/');
  },
  filename: function (req, file, cb) {
    cb(null, Date.now() + path.extname(file.originalname));
  },
});
const upload = multer({ storage });

app.post('/tickets', upload.array('fotos'), async (req, res) => {
  try {
    const { clienteNombre, empresa, area, telefono, impresora, descripcionFalla, clienteId } = req.body;
    const fotos = req.files?.map(file => `http://localhost:3000/uploads/${file.filename}`) || [];

    const nuevoTicket = new Ticket({
      clienteNombre,
      empresa,
      area,
      telefono,
      impresora,
      descripcionFalla,
      clienteId,
      fotos
    });

    await nuevoTicket.save();

    // ‚úÖ Enviar notificaci√≥n push
    enviarNotificacion({
      title: 'üì¢ Nuevo Ticket',
      body: `${empresa} - ${area}: ${descripcionFalla}`,
    });

    enviarNotificacionExpo({
  title: 'üì¢ Nuevo Ticket',
  body: `${empresa} - ${area}: ${descripcionFalla}`,
});

    res.json(nuevoTicket);
  } catch (error) {
    console.error('Error al crear ticket:', error);
    res.status(500).json({ error: 'Error al crear ticket' });
  }
});

app.post('/toner', upload.none(), async (req, res) => {
  try {
    const { clienteNombre, empresa, area, telefono, impresora, clienteId } = req.body;

    const nuevoToner = new Toner({
      clienteNombre,
      empresa,
      area,
      telefono,
      impresora,
      clienteId
    });

    await nuevoToner.save();
    console.log('‚úÖ Pedido de t√≥ner guardado:', nuevoToner);

    // ‚úÖ Enviar notificaci√≥n push
    enviarNotificacion({
      title: 'üü£ Nuevo pedido de t√≥ner',
      body: `${empresa} - ${area} ha solicitado un t√≥ner`,
    });

    enviarNotificacionExpo({
  title: 'üü£ Nuevo pedido de t√≥ner',
  body: `${empresa} - ${area} ha solicitado un t√≥ner`,
});

    res.status(201).json({ message: 'Pedido de t√≥ner registrado correctamente', toner: nuevoToner });
  } catch (error) {
    console.error('‚ùå Error al registrar pedido de t√≥ner:', error);
    res.status(500).json({ error: 'Error al registrar pedido de t√≥ner' });
  }
});

// ‚úÖ Ruta para actualizar estado o t√©cnico del T√ìNER
app.patch('/toners/:id', async (req, res) => {
  try {
    const tonerAnterior = await Toner.findById(req.params.id);
    const toner = await Toner.findByIdAndUpdate(req.params.id, req.body, { new: true });

    if (!toner) return res.status(404).json({ error: 'T√≥ner no encontrado' });

    // ‚úÖ Notificaci√≥n cuando se asigna un t√©cnico
if (!tonerAnterior.tecnicoAsignado && toner.tecnicoAsignado) {
  enviarNotificacionACliente({
    clienteId: toner.clienteId,
    title: 'üë®‚Äçüîß T√©cnico asignado a tu pedido de t√≥ner',
    body: `T√©cnico ${toner.tecnicoAsignado} ha sido asignado a tu pedido en ${toner.empresa} - ${toner.area}.`,
  });
}

    res.json(toner);
  } catch (error) {
    console.error('‚ùå Error al actualizar t√≥ners:', error);
    res.status(500).json({ error: 'Error al actualizar t√≥ners' });
  }
});
app.delete('/toners/:id', async (req, res) => {
  try {
    await Toner.findByIdAndDelete(req.params.id);
    res.json({ message: 'T√≥ner eliminado correctamente' });
  } catch (error) {
    console.error('Error al eliminar t√≥ner:', error);
    res.status(500).json({ error: 'Error al eliminar t√≥ner' });
  }
});

app.get('/tickets', async (req, res) => {
  try {
    const clienteNombre = req.headers['cliente-nombre'];
    let tickets;

    if (clienteNombre) {
      tickets = await Ticket.find({ clienteNombre });
    } else {
      tickets = await Ticket.find();
    }

    res.json(tickets);
  } catch (error) {
    console.error('Error al obtener tickets:', error);
    res.status(500).json({ error: 'Error al obtener tickets' });
  }
});


app.get('/toners', async (req, res) => {
  try {
    const clienteId = req.headers['cliente-id'];
    const query = clienteId ? { clienteId } : {};

    const toners = await Toner.find(query);
    res.json(toners);
  } catch (error) {
    console.error('‚ùå Error al obtener t√≥ners:', error);
    res.status(500).json({ error: 'Error al obtener t√≥ners' });
  }
});

app.get('/tickets/:id', async (req, res) => {
  try {
    const ticket = await Ticket.findById(req.params.id);
    if (!ticket) return res.status(404).json({ error: 'Ticket no encontrado' });
    res.json(ticket);
  } catch (error) {
    console.error('Error al obtener ticket:', error);
    res.status(500).json({ error: 'Error al obtener ticket' });
  }
});


app.get('/toners/:id', async (req, res) => {
  try {
    const toner = await Toner.findById(req.params.id);
    if (!toner) return res.status(404).json({ error: 'T√≥ner no encontrado' });
    res.json(toner);
  } catch (error) {
    console.error('Error al obtener toner:', error);
    res.status(500).json({ error: 'Error al obtener toner' });
  }
});

app.patch('/tickets/:id', async (req, res) => {
  try {
    const ticketAnterior = await Ticket.findById(req.params.id);
    const ticket = await Ticket.findByIdAndUpdate(req.params.id, req.body, { new: true });

    if (!ticket) return res.status(404).json({ error: 'Ticket no encontrado' });

    // ‚úÖ Notificaci√≥n cuando se asigna un t√©cnico
    if (!ticketAnterior.tecnicoAsignado && ticket.tecnicoAsignado) {
  enviarNotificacionACliente({
    clienteId: ticket.clienteId,
    title: 'üë®‚Äçüîß T√©cnico asignado a tu ticket',
    body: `T√©cnico ${ticket.tecnicoAsignado} ha sido asignado a tu ticket en ${ticket.empresa} - ${ticket.area}.`,
  });
}

    res.json(ticket);
  } catch (error) {
    console.error('Error al actualizar ticket:', error);
    res.status(500).json({ error: 'Error al actualizar ticket' });
  }
});

app.delete('/tickets/:id', async (req, res) => {
  try {
    await Ticket.findByIdAndDelete(req.params.id);
    res.json({ message: 'Ticket eliminado correctamente' });
  } catch (error) {
    console.error('Error al eliminar ticket:', error);
    res.status(500).json({ error: 'Error al eliminar ticket' });
  }
});

app.get('/tecnicos', async (req, res) => {
  try {
    const tecnicos = await Tecnico.find();
    res.json(tecnicos);
  } catch (error) {
    console.error('Error al obtener t√©cnicos:', error);
    res.status(500).json({ error: 'Error al obtener t√©cnicos' });
  }
});

// ‚úÖ NUEVA RUTA PARA AGREGAR T√âCNICOS
app.post('/tecnicos', async (req, res) => {
  try {
    const { nombre, fotoUrl } = req.body;

    const nuevoTecnico = new Tecnico({
      nombre,
      fotoUrl,
    });

    await nuevoTecnico.save();

    res.status(201).json({ message: 'T√©cnico agregado correctamente', tecnico: nuevoTecnico });
  } catch (error) {
    console.error('Error al agregar t√©cnico:', error);
    res.status(500).json({ error: 'Error al agregar t√©cnico' });
  }
});

app.delete('/tecnicos/:id', async (req, res) => {
  try {
    await Tecnico.findByIdAndDelete(req.params.id);
    res.json({ message: 'T√©cnico eliminado correctamente' });
  } catch (error) {
    console.error('Error al eliminar t√©cnico:', error);
    res.status(500).json({ error: 'Error al eliminar t√©cnico' });
  }
});

app.patch('/tecnicos/:id', upload.single('foto'), async (req, res) => {
  try {
    const tecnico = await Tecnico.findById(req.params.id);
    if (!tecnico) {
      return res.status(404).json({ error: 'T√©cnico no encontrado' });
    }

    if (req.body.nombre) {
      tecnico.nombre = req.body.nombre;
    }

    if (req.file) {
      const fotoUrl = `http://localhost:3000/uploads/${req.file.filename}`;
      tecnico.fotoUrl = fotoUrl;
    }

    await tecnico.save();
    res.json({ message: 'T√©cnico actualizado correctamente', tecnico });
  } catch (error) {
    console.error('Error al actualizar t√©cnico:', error);
    res.status(500).json({ error: 'Error al actualizar t√©cnico' });
  }
});

app.post('/login', async (req, res) => {
  const { email, password } = req.body;
  try {
    const usuario = await Usuario.findOne({ email });
    if (!usuario) {
      return res.status(401).json({ error: 'Usuario no encontrado' });
    }

    const passwordOk = await bcrypt.compare(password, usuario.password);
    if (!passwordOk) {
      return res.status(401).json({ error: 'Contrase√±a incorrecta' });
    }

    if (!usuario.activo) {
      return res.status(403).json({ error: 'Licencia inactiva, contacta a soporte' });
    }

    res.json({ message: 'Login exitoso' });
  } catch (error) {
    console.error('Error en login:', error);
    res.status(500).json({ error: 'Error en login' });
  }
});

app.post('/validar-licencia', async (req, res) => {
  const { licencia } = req.body;

  if (!licencia || licencia.trim() === '') {
    return res.status(400).json({ validado: false, error: 'Licencia vac√≠a' });
  }

  res.json({ validado: true });
});

app.post('/registrar-token', async (req, res) => {
  const { clienteId, expoPushToken } = req.body;

  if (!clienteId || !expoPushToken) {
    return res.status(400).json({ error: 'Datos incompletos' });
  }

  try {
    const existente = await PushToken.findOne({ clienteId });

    if (existente) {
      existente.expoPushToken = expoPushToken;
      await existente.save();
    } else {
      const nuevo = new PushToken({ clienteId, expoPushToken });
      await nuevo.save();
    }

    res.status(200).json({ message: '‚úÖ Token registrado correctamente' });
  } catch (error) {
    console.error('‚ùå Error al guardar token push:', error);
    res.status(500).json({ error: 'Error interno al guardar token' });
  }
});

app.get('/tickets-tecnico', async (req, res) => {
  const licencia = req.headers['tecnico-licencia'];

  if (!licencia) {
    return res.status(400).json({ error: 'Licencia no proporcionada' });
  }

  try {
    const tickets = await Ticket.find({ tecnicoAsignado: licencia });
    res.json(tickets);
  } catch (error) {
    console.error('Error al obtener tickets para t√©cnico:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
});

app.post('/tickets/:id/finalizar', upload.array('fotosTecnico'), async (req, res) => {
  try {
    const ticket = await Ticket.findById(req.params.id);
    if (!ticket) return res.status(404).json({ error: 'Ticket no encontrado' });

    const comentario = req.body.comentario || '';
    const nuevasFotos = req.files?.map(file => `http://localhost:3000/uploads/${file.filename}`) || [];

ticket.estado = 'Terminado';

    ticket.fotos.push(...nuevasFotos);
    // ticket.comentarioTecnico = comentario; // Si decides guardar comentarios en el modelo

    await ticket.save();

    res.json(ticket);
  } catch (error) {
    console.error('Error al finalizar ticket:', error);
    res.status(500).json({ error: 'Error al finalizar ticket' });
  }
});
// ‚úÖ Nueva ruta: obtener t√≥ners asignados a un t√©cnico
app.get('/toners-tecnico', async (req, res) => {
  const licencia = req.headers['tecnico-licencia'];

  if (!licencia) {
    return res.status(400).json({ error: 'Licencia no proporcionada' });
  }

  try {
    const toners = await Toner.find({ tecnicoAsignado: licencia });
    res.json(toners);
  } catch (error) {
    console.error('Error al obtener t√≥ners para t√©cnico:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
});

const PORT = 3000;
app.listen(PORT, () => {
  console.log(`Servidor corriendo en http://localhost:${PORT}`);
  
});

